Advance Window Functions
Window functions in SQL are powerful tools that provide advanced analytical capabilities, allowing users to perform complex calculations across sets of rows related to the current query row. These functions are used to generate ranking, cumulative, and moving aggregates that cannot be easily achieved using standard aggregate functions.

Theory Behind Window Functions
Window functions operate on a set of rows defined by an OVER clause, which specifies the partitioning and ordering of rows. Unlike aggregate functions, which return a single result for a group of rows, window functions return a value for each row in the set.

Key Concepts
Partitioning: Divides the result set into partitions to which the window function is applied.
Ordering: Defines the order in which the rows are processed within each partition.
Framing: Specifies the subset of rows within the partition to be considered for the function.
Common Window Functions
Ranking Functions: RANK(), DENSE_RANK(), ROW_NUMBER()
Aggregate Functions: SUM(), AVG(), MIN(), MAX()
Value Functions: LEAD(), LAG(), FIRST_VALUE(), LAST_VALUE()
Practical Examples
Lets explore advanced window functions with practical examples using a hypothetical restaurants table from the swiggy database.

Example Dataset: restaurants
Consider a simplified version of the restaurants table with columns:

id: Unique identifier
name: Restaurant name
city: City where the restaurant is located
cuisine: Type of cuisine served
rating: Average rating of the restaurant
rating_count: Number of ratings received
cost: Average cost per meal
Example 1: List the Top 5 Cuisines by Revenue Generated by the Top 5 Restaurants of Every Cuisine
This query identifies the top 5 cuisines based on the revenue generated by their top 5 restaurants.

SELECT cuisine, SUM(rating_count * cost) AS 'revenue'
FROM (
    SELECT *,
           cost * rating_count,
           ROW_NUMBER() OVER(PARTITION BY cuisine ORDER BY cost * rating_count DESC) AS 'rank'
    FROM restaurants
) t
WHERE t.rank <= 5
GROUP BY cuisine
ORDER BY revenue DESC;
Explanation:
Subquery: Calculates the revenue (cost * rating_count) for each restaurant and assigns a rank within each cuisine based on this revenue.

Filter: Keeps only the top 5 restaurants (WHERE t.rank <= 5) for each cuisine.

Group By and Aggregate: Sums the revenues for each cuisine to determine the total revenue generated by the top 5 restaurants.

Order: Sorts the results by revenue in descending order to list the top 5 cuisines.

Output:
cuisine

revenue

Italian

16550

Japanese

7200

Mexican

7250

Example 2: Determine the Total Revenue Generated by the Top 1% of Restaurants
This query calculates the total revenue generated by the top 1% of restaurants based on revenue.

SELECT SUM(cost * rating_count) AS 'revenue'
FROM (
    SELECT *,
           cost * rating_count,
           ROW_NUMBER() OVER(ORDER BY cost * rating_count DESC) AS 'rank'
    FROM restaurants
) t
WHERE t.rank <= 614;
Explanation:
Subquery: Calculates the revenue (cost * rating_count) for each restaurant and assigns an overall rank based on this revenue in descending order.

Filter: Selects the top 1% of restaurants (WHERE t.rank <= 614), assuming the dataset has 61,400 restaurants.

Aggregate: Sums the revenues of these top 1% restaurants to determine the total revenue.

Output:
Revenue

22000



Example 3: Determine the Total Revenue Generated by the Top 20% of Restaurants
This query calculates the total revenue generated by the top 20% of restaurants based on revenue.

SELECT SUM(cost * rating_count) AS 'revenue'
FROM (
    SELECT *,
           cost * rating_count,
           ROW_NUMBER() OVER(ORDER BY cost * rating_count DESC) AS 'rank'
    FROM restaurants
) t
WHERE t.rank <= 12280;
Explanation:
Subquery: Calculates the revenue (cost * rating_count) for each restaurant and assigns an overall rank based on this revenue in descending order.

Filter: Selects the top 20% of restaurants (WHERE t.rank <= 12280), assuming the dataset has 61,400 restaurants.

Aggregate: Sums the revenues of these top 20% restaurants to determine the total revenue.

Output:


Example 4: Percentage of Revenue Generated by the Top 20% of Restaurants
This query calculates the percentage of the total revenue that is generated by the top 20% of restaurants.

WITH 
    q1 AS (
        SELECT SUM(cost * rating_count) AS 'top_revenue'
        FROM (
            SELECT *,
                   cost * rating_count,
                   ROW_NUMBER() OVER(ORDER BY cost * rating_count DESC) AS 'rank'
            FROM restaurants
        ) t
        WHERE t.rank <= 12280
    ),
    q2 AS (
        SELECT SUM(cost * rating_count) AS 'total_revenue'
        FROM restaurants
    )
SELECT (top_revenue / total_revenue) * 100 AS 'revenue_percentage'
FROM q1, q2;
Explanation:
CTE q1: Calculates the total revenue generated by the top 20% of restaurants.

CTE q2: Calculates the total revenue generated by all restaurants.

Final Select: Computes the percentage of the total revenue generated by the top 20% of restaurants by dividing top_revenue by total_revenue and multiplying by 100.

Output:
revenue_percentage

50.00



Conclusion
Advanced window functions in SQL are indispensable for performing sophisticated data analysis and generating detailed insights. They allow for complex calculations over a specified set of rows, providing the flexibility to rank, aggregate, and analyze data within different partitions and orders.

By understanding and utilizing these functions, users can efficiently perform tasks like ranking restaurants by revenue, calculating cumulative totals, and more. These advanced techniques empower analysts and developers to derive meaningful insights from their data, leading to better decision-making and business strategies.
